# 동시성 이슈

- 나의 시나리오에서 발생 가능한 동시성 이슈에 대해 파악
- 가능한 동시성 제어 방식을 도입해보고 장단점을 파악한 내용을 정리 및 제출
- 발제 영상 다시보며 동시성 문제 정리하기

## 발제 영상다시 보며 동시성 문제 정리

### 동시성 문제

- 여러작업(프로세서, 스레트, 트랜잭션 ..) 이 공통된 리소스(자원)에 접근 할 때 발 생하는 문제
- 데이터를 수정하고 저장하였으나 조회시 예상 되는 결과값과 다른 결과가 나오는 경우
    - 테이터 무결성이 깨져 정합성을 저해 시킴

#### 동시성 이슈에 대한 원인

- 상호 배제 ( Mutual Exclusion )
    - 한번에 하나의 작업만 특정 리소스에 접근 가능 하도록 막는 방식
    - DataBase Lock을 이용해서 만듬
- 교착 상태 ( Deadlock )
    - 두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 무한 대기 상태에 빠지는 현상

#### DB에서의 동시성 문제

- 분실 갱신 (Lost Update)
    - 두개 이상의 트랜잭션이 동시에 같은 데이터를 수정할 때 발생
    - 먼저 실행된 트랜잭션이 커밋되기 전에 뒤에 실행된 트랜잭션이 덮어쓰기를 하여 데이터가 손실되는 문제
- 커밋되지 않은 의존 ( Uncommitted Dependency )
    - 한 트랜잭션이 데이터를 수정하고 커밋하지 않은 상태에서 다른 트랜잭션이 수정된 데이터를 읽어들이는 문제
- 모순 감지 ( Inconsistency Analysis )
    - 트랜잭션이 실행중에 다른 트랜잭션이 데이터 수정에 개입하여 데이터의 일관성이 깨지는 문제

#### DB Transaction 격리 수준에 따른 Read, Write 문제

- Dirty Read
    - 한 트랜잭션이 데이터를 수정하고 커밋하지 않은 상태에서 다른 트랜잭션이 수정된 데이터를 읽어들이는 문제
- Non-Repeatable Read
    - 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 데이터를 수정하거나 삭제하여 처음에 읽은 데이터와 다른 데이터를 읽어들이는 문제
- Phantom Read
    - 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 데이터를 삽입하여 처음에 읽은 데이터에 없던 데이터가 나타나는 문제

#### DB Transaction 격리 수준

- Read Uncommitted
    - 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있음
    - Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
- Read Committed
    - 다른 트랜잭션이 커밋한 데이터만 읽을 수 있음
    - Non-Repeatable Read, Phantom Read 발생 가능
- Repeatable Read
    - 트랜잭션이 시작되기 전에 읽은 데이터는 트랜잭션이 종료될 때까지 변경되지 않음
    - Phantom Read 발생 가능
    - 예외 ) MySQL의 Default - InnoDB (Phantom Read가 발생하지 않는다.)
        - next-key lock을 사용하여 해결
        - next-key lock은 인덱스 레코드와 인덱스 레코드 사이의 공간을 잠그는 방식
- Serializable
    - 트랜잭션은 순차적으로 실행되어야 함

#### Lock을 이용한 동시성 제어

- 낙관적 락 ( Optimistic Lock )
    - 버전 정보를 이용하여 충돌을 감지하는 방식
    - 충돌 빈도가 적을 경우 권장
    - 동시 요청중 한건만 성공해야 하는 케이스에 적합
- 비관적 락 ( Pessimistic Lock )
    - 데이터를 읽을 때 미리 Lock을 걸어 다른 요청이 접근하지 못하도록 하는 방식
    - 충돌 빈도가 높을 경우 권장
    - 동시 요청중 여러건이 성공해야 하는 케이스에 적합

#### 다른 동시성 제어 기법

- 분산락 ( Distributed Lock )
    - 여러 서버에서 공유하는 리소스에 대한 Lock을 걸어 동시성 문제를 해결하는 방식
    - Redis 등을 이용하여 구현
    - SETNX 을 이용하여 구현
    - SETNX 사용 시점 : 중복 삽입을 방지, 동시성 제어, 락을 걸어 작업을 원자적으로 처리

- Simple Lock
    - Key 선점에 의한 lock 획득 실패시 비즈니스 로직을 실행하지 않음
    - 실패 시 재시도 로직에 대한 고려가 필요

- Spin Lock
    - Locak 획득 실패 시 일정 시간 / 횟수 동안 Lock 획득을 시도
    - 재시도 로직에 대한 고려가 필요하고 재시도에 필요한 네트워크 재전송 비용 고려 필요

- Pub/Sub
    - Redis의 Pub/Sub을 이용하여 동시성 제어
    - 락획득을 실패 했을 때 구독 하고 차례가 될 때 까지 이벤트를 기다리는 방식으로 Lock 관리가 가능
    - 구독한 subscriber가 들 중 먼저 선점한 작업만 Lock 해제가 가능함으로 안정적으로 원자적 처리가 가능

## 동시성 이슈 해결시 고민 방안

- DB의 Lock, Redis의 분산락을 이용해 구현 하는 경우 시스템 전체에 어느정도의 부하를 주는가?
- 데이터의 무결성과 영속성을 보장하는가?
- 구현하는데 복잡함, 어려움이 있는가?(인프라 비용 등)

## 나의 발생 가능한 동시성 이슈

- 유저 포인트 충전
    - 기존 : 비관적 락 사용
    - 유저 포인트의 정합성을 위해 락 사용
    - 분산락 적용시 : 유저 ID에 대해 Lock 생성

- 쿠폰 발급 ( 쿠폰 재고 차감 )
    - 기존 : 비관적 락 사용
    - 쿠폰 재고 관리를 위해 락 사용
    - 분산락 적용시 : 쿠폰 ID에 대해 Lock 생성

- 주문 ( 쿠폰 사용, 재고 차감 )
    - 기존 : 비관적 락 사용
    - 주문시 재고 차감, 쿠폰 사용여부 관리를 위해 락 사용
    - 분산락 적용시 : ?? 뭐에 락을 걸어야 할까?
    - => 고민되는 이유 : 주문 시 여러건의 재품을 주문 할 수 있고 제품마다 각각의 제고가 존재함 => 주문의 경우 분산락을 적용하지 않고 비관적 락을 사용

- 결제 ( 유저 포인트 차감, 주문 상태 변경 )
    - 기존 : 비관적 락 사용
    - 유저의 포인트 차감에 대한 정합성과 주문 상태 변경을 위해 락 사용 ( 하나의 주문으로 여러건의 결재를 진행하지 못하도록 )
    - 분산락 적용시 : 주문 ID에 대해 Lock 생성

## 트랜잭션과 Lock

확인 방법 : JpaTransactionManager, doBegin에 중단점 찍어서 테스트